== Bugs ==

TODO: !!!Major!!! If you name something a document with a period, and then give it
subdocuments, its shows up in two entries in a list. For example: 
1. create("I. The Call")
2. create("I. The Call/Home")
3. list()
The result is:
I
I. The Call

Also, does weird things when you call edit, and rename. Just try:
edit("I. The Call") 
rename("I. The Call","I The Call") 
and see what happens.

Basically, the whole file extension thing isn't working with all things.
This could also mean problems with underscores. The answer might be to
make '.' and '_' into bad name characters, but that might also be overkill.

TODO: When calling order after/before with a relativeTo that isn't ordered,
the index doesn't actually change relative to the other doc, i think it
just moved the doc to the end. Instead, it should really report an error
indicating that the relative document does not exist.

TODO: When calling list on the root directory of a project, docs are
not listed in the order of their index. I suspect it's looking in the wrong
place to get the data.

TODO: When calling order after/before with a relativeTo doc, the relativeTo
value is resolved against the current directory, even if we're moving a
doc outside of that directory. I think it should probably resolve against
the parent directory of the file whose order is being changed.

TODO: When calling a command that returns an empty standard object (such
as "get" on a doc that has no value for the properties), "[Object]" is 
returned instead of something else that indicates an empty "<object>".

TODO: I had a doc named something like "A scene...", including the dots at
the end. I attempted to set it's "category" to "Task". The new value shows up
in the properties.json file, but it did not change the color with the list
command, and when listing the category as well, the category was the default
category. Renaming the files so that the ending dots weren't there fixed this.

TODO: When formatting the content of an empty object or array for output,
it comes out as [object Object], or something like that. It should come out
with "<none>" or something like that.

TODO: When formatting an object in a table, and the object is in the second column,
the column does not seem to be indented appropriately.

TODO: When you rename the current document itself, the current working document
does not change, and you get into a situation where you can't do anything because
it keeps saying "Attempted to get a document that doesn't exist"

== Features ==
 
TODO: Convert SFMS, to work with Promises instead of callbacks.
    
TODO: The properties in the core should have a way of listing all user property names.
 
TODO: It would be nice if the command line would retain it's history between
sessions, perhaps with a max limit, of course.
 
TODO: "Set" should allow a null value or undefined to delete a property value.
 
TODO: Now that I've got selectors, updators are useful too, for mass
 update of fields using list (or perhaps a separate, similar command, like `update`)

TODO: List should at least have an option for indicating files that are directories. For
example, a '+' sign next to it, or something. Or a Wingding folder symbol, if there is one.
I've got the "glyph" style added to the formatters, it shouldn't be too difficult to add
this to the list command.

TODO: When printing out the synopsis in a list, it extends over the edge of the screen, instead of being
wrapped around. I wonder if I should be putting some sort of "wrap style" on the synopsis when it's retrieved.

TODO: When creating documents, it would be nice to be able to set some properties at the same time.
With the creation of 'setters', mentioned elsewhere, this could be done easily.

TODO: I really want to be able to color things according to either status, or some tag, instead of
 category. Or, give the user the ability to do this. I mean, coloring by category is nice, but I'd rather
 make it easier to find the items that haven't been done yet: My use of Task as a category to make things
 red is a kludge. Yes, Tasks should be red, but the category of these docs should be Scene, not Task.
 Therefore, I would rather be able to see scenes with a status of "To Do" be red instead. 
 
 One option: categories get a little "bullet" next to them, which is printed in the color it should be,
 and statuses also get a color, which is applied to the actual text. In a GUI, categories might be
 able to get an icon, so this is close to what I want.
 
TODO: A Rename doesn't keep order. It should. But then, that would also
mean we *would*, after all, have to maintain references as well.

TODO: A new "command syntax". Although the JavaScript thing is convenient
in allowing for more complex code, I rarely use it, and it actually makes
things more complex for what I want it for.

Basically, it would be a syntax similar in nature to a shell syntax, wherein
everything is whitespace separated arguments. An argument can
be a number, an identifier (text with no quotes and no spaces) or a quoted
string (quotes surrounding text with any amount of whitespace and other
special characters). Also, the "simple expression" syntax should be a subset
of the syntax, so it can be converted easily. I might also add some sort
of script resolving syntax, such as "{...}" to allow javascript evaluation.

Each command is therefore turned into a list of arguments, either string,
identifier, or number. The first and, often, second ones are the most a
important in looking up an appropriate action.

If the first argument is an identifier, an attempt will be made to resolve
it first to a command, then to a document relative to the current if no
command is found. If the first argument is a quoted string, it will try
to resolve to a document first, then a command if no such document is found.
If it can't be resolved to either, an error will be reported.

If the first argument is resolved to a command, then:
- If the command is marked as a "document" command, the command will be
  called with the current working document as the first argument, and any
  remaining arguments from the command line following that.
- If the command is marked as "non-document", meaning it doesn't require
  a document to run against, the command will simply be passed all of the
  remaining arguments.
  
If the first argument is resolved to a document, then an attempt will be
made to resolve the second argument to a command. If a command is found,
and that command is a "document" command, the command will be called with
the specified document as the first argument, and the remaining arguments
following that. If no command is found, an error will be reported. However,
if no second argument was passed, a "goto" command is assumed.

== New Commands and Data Structures ===
 
TODO: Need a "Help" task which lists all of the commands, and also explains them when a command is specified.

TODO: Need to handle User Tasks. Basically, my first instinct is that these are
stored in an attachment labeled _tasks.txt, probably using something like a
todo.txt format. That way, tasks can be applied to specific documents, rather
than be in a separate section and have to reference those docs
(although global tasks would be available too). There would be four commands:
- tasks list: list's tasks in the current directory, or global tasks, sorted
according to priority and due date.
- tasks create: creates a task either for a document or globally. It should also
be possible to add a task to multiple files based on tags or something else.
- tasks edit: edit the description of a task, and the start and due dates associated with it.
- tasks priority: set a priority of a task.
- tasks done: marks a task as completed, possibly with a reason.

There might be a "current" task as well, so I would do "task work" to take
the top task off the list and work on it, "task done" to mark it as completed
and "task next"/"previous" to switch tasks, or "task quit" to stop working
with the current task. The current task would be in saved state, and would
be displayed on opening up stew.

The task thing could actually be part of a workflow system, nudging you to keep going.
1) A task can be associated with documents, that are opened up as soon as you start working on the task.
2) When you start up stew, the current task will immediately pop up and ask to be worked on (this should be optional,
in case you started up stew to open up a different project temporarily).
3) When you close up stew for the day, it will ask you if you are done with the task or if you need to keep working on it.
4) Tasks can be associated with "production" goals, such as word-count, file counts, files at a given status, etc. This is a bit more complex, since you need to give it a filter to watch, and it has to be able to handle document types. These goals can be "verified" to have the current values recalculated and determine if they've been reached, recorded for historical reference, compared with previous values, and come up with ETA's.
5) There might also be reminders, scheduled to pop up occasionally, such as on start up or shut down. These could be used to help get your mind back on track, or to remember to write in your journal at the end of the day, etc. These reminders cou

Then again, these sorts of things might wait until we have a GUI program going.

TODO: Need to be able to store current document locations and return to them quickly. I'd like an
 Alt-Tab type interface for this, rather than trying to remember bookmark names, or using a stack
 like pushd and popd. For example, a command "switch" would put it into a mode where it's waiting 
 for keys. An arrow key right or left would cycle through a set of previous locations, perhaps even 
 open projects (but that would require a lot more changes). If you don't press anything for a 
 second or so, it would just switch back and forth between the two most recent, like Alt-Tab. 
 I wonder if I could use a Ctrl-Tab key command instead?
 
TODO: Need a mechanism to make it easy to send a certain set of pieces
 (by category, or tag, for example) to a cloud service, and pull them
 back in again later. Since this would involve mechanisms out of scope
 for stew, this is almost a different command line. But, at the very
 least, I could create a system for syncing a certain set of files with
 another folder. But, since some cloud services support tags, if I
 had specific mechanisms, it would work great. This is probably a 'plugin'
 oriented mechanism.
 
TODO: A "view" mechanism would be nice, so I can save a search for all
 docs marked with some property, for example. -- This is fairly simple
 to solve within a session: var view = list.bind(null,".","foo*","category")
 But, this isn't saveable across sessions. Some sort of macro mechanism
 would fix that. Possibly, a dot-command:
 .macro <name> <code>.
 
 The macro would be stored in the project settings and evaluated into 
 a variable with the specified name at startup (as well as upon creation). 
 That way, it would be 1) Saveable in text form and 2) bound to the 
 correct scopes.
 
 But, macros are security problems. Better would be just a view definition
 thing, and you could just type view("foo"), or better yet, view.foo().
 This could then be stored in the project itself, in _stew.json.
 
TODO: Another useful tool: 
 stew recent [number | string]: 
 - basically, whenever a project is opened in interactive stew, it is
 recorded as recently opened in the global settings file. The recent command would list
 these files (it should also be able to clear them). If passed a parameter, 
 it will open the repl with either the project file found at that index, or 
 would open the repl with the project whose basename is the specified string. 
 (If mru is used within the repl already, it will just list the files or 
 open the project, obviously)
 
TODO: Not really a new command, but a new way of handling commands.
Certain commands currently take a "doc" object as the first parameter,
which is optional unless there is no way to figure out by the parameter
types, making it a little tough. What if:
- Whenever the current working document is changed, the context is changed.
The documents in the current context become "commands". Specifying a
document name followed by a command causes the command to be called with
the document as the first parameter. Specifying the command alone causes 
the command to be called with the current document as the parameter. 
- Now, I don't want to have to scan the whole directory with every 
directory switch, so that I can add in subdirs and parent dirs, so it's 
possible that this might require some pre-parsing before parsing as JavaScript.
Or, maybe this is better done with another syntax more like a shell.
 
TODO: Finish implementing the unimplemented commands.

TODO: Publishing:

pandoc can combine files, which would be great, if it read from all of
the possible formats I can think of. It doesn't allow ODT as an input format,
but I can just add in a preprocessor for that stuff. Anyway, here goes:
- "publish" requires pandoc to be installed on the system. (A call to
"pandoc -v" can confirm it's existence, and at some point help us figure
out whether certain things need to be done first based on version number)
- It calls a 'publish' function in stew-core, because that's really where
this needs to be. This is where the work is done.
- The publish command requires a parameter specifying the output type for pandoc.
- The list of documents to be published will be the same
as calling listDocs with a "recurse(publish)" filter on the document on 
which publish is called, except it will also include itself as a document.
- if a document to be published is an .odt file, then "libreoffice" is required
as well, because pandoc can not open ODT yet. (A call to "libreoffice --version" 
can confirm it's existence, and help with capabilities in the future).
- Some new properties on the documents as well:
  - title: Sometimes, the "name" of the document isn't the same as the title, probably because of filename issues.
- And some new properties on "categories":
  - publishTitle: Specifies whether the 'title' of the specified object should be published.
  - titleLevel: Specifies the "level" of the category when published. For example, "book" might be level 1, "chapter" level 2, etc.
  - titlePrefix: Specifies the text to appear before the prefix to be included (will appear before the 'number'. For example, "Book", "Chapter". Also, certain substitution parameters can be in cluded:
    - %R: insert a capital roman numberal here, according to the number of other items in the category in the published document.
    - %N: insert an arabic numeral here, according to the numbers of the other items in the category in the published document.
    - %A: insert a capital alphabetic letter here, according to the numbers of the other items in the category in the published document.
  - publishTitle: specifies whether the title should be "published" when an item of this category is published.
  - publishBreakBefore: specifies whether a page break should occur before the item when published.
  - publishBreakAfter: specifies whether a page break should occur after the item when publisshed.
  - publishMarkerBetween: specifies whether a section marker should occur between two items of the same category.
- Okay, so here goes the process:
  - build a list of documents to be published. this is done as mentioned above.
  - create a "numbers" object which will contain category names mapped to numbers.
  - create a "files" list which will contain paths of files to be put together with pandoc.
  - With each document:
    - look at it's category. 
      - if the category says "publishTitle" is true, then:
        - create a temporary "before" file containing the 'title' of the document from it's properties, or the basename of the 
          document if that doesn't exist. The "text" file is going to be in markdown, html or possibly latex.
        - if the category has a titleLevel, then the title's level is specified according to that, otherwise it will get a level of 1.
        - if the category has a titlePrefex, then that has to be calculated (including the substitution parameter) and applied to
        the text file. If the category is not mentioned in the "numbers" object, give it a number of 1, and set the property on the numbers object to 2. Otherwise, give it the number from the "numbers" object, and increment that. Translate the number
        according to the substitution variable provided.
      - if the category says "publishBreakBefore" is true, then do whatever it takes to put a page break into the "before" file. I have to play around with this, if the text file is in latex format, I might be able to insert the page break there and get it to convert to ODT or whatever.
      - if the category says "publishMarkerBetween", and the previous item processed was the same category, create a "between" text file indicating that a horizontal rule, or something else (I have to figure out what to do there).
      - if the category says publishBreakAfter, create an "after" file for after, see publishBreakBefore a little above.
    - if the file is an "ODT" file, use libreoffice --headless to convert it to HTML first, because pandoc can't read ODT.
        See: http://ask.libreoffice.org/en/question/1686/how-to-not-connect-to-a-running-instance/ for how to do it to ensure
        that this will work whether libreoffice is running or not already. NOTE: This will change if pandoc ever supports ODT
        input.
    - Now, add the files in order to a list of files to process:
        - the "between" file if it exists.
        - the "before" file if it exists.
        - the document file (either the original file, or the HTML file converted from ODT) 
        - the "after" file if it exists.
  - Now, build a pandoc command line. Parameters are ["-s","-o",outputfileName].concat(files array to be process). And run it.      



== Unreproducible Bugs ==

TODO: Trying to find a document with an apostrophe in it's name
 doesn't work. This happens with any command when specifying it as a
 path, or when comparing the names themselves (for example, when used
 as a predicate for "after"). 
 -- Can't confirm this issue. It seems to work fine now. I wonder if I
    had a title that had a single curly quotation mark instead of an
    apostrophe.

== GUI ==
 
TODO: Work on a GUI. So far, I have a few options:
 - an "ncurses"-like interface -- which might or might not be easier
 to do, but could easily be used to almost replace the CLI.
 - a node-webkit interface -- which would be fine, but I'm still
 worried about performance, especially with bugs that I've seen in
 my nw-ssb stuff (although I've been pin-pointing those to the sites
 themselves).
 - also, look at something called atom-shell, which appears to be
 similar to node-webkit, I'm not sure how it's different. It's backed
 by github, and specifically used for writing a standalone IDE for them,
 (not sure why they need one). There are several architectural differences
 which seem to make sense (more context separation between back and front,
 no "single main window" which was always my issue with Delphi, and
 which NW seems to maintain).
 
 I wish I could create the GUI in gtk or qt or something, to improve
 things, but that only really makes sense if I rewrite the libraries
 in some language which those can connect to -- or if someone finishes
 and maintains all of those various node-gtk or -qt links.
 
 Of course, I could also learn some simple cross-platform compilable 
 language (valac?, C++?) that binds to these and rewrite the whole 
 thing in that. Probably, the best choice right now is Qt, but I'm
 not sure what it's future is. It does seem to support Mac, and probably
 IOS, better than Gtk.
 
 -- Honestly, I'm tempted to just go straight to Qt when I'm ready
 to create the GUI. The rewrite of the back end might be easier if
 there's no callback hell involved -- not to mention they do support
 JavaScript in their QML/QtQuick system.
 
 -- Might be better to create a Qt Markdown Editor first, then I could retain
 the feature of being able to store whatever file types you want in this,
 and therefore make the editor optional.

 -- 2014/12/11: I've done further research into possibilities here, 
    written out in my notes elsewhere for a Markdown Editor. This can
    be done with Qt, Java, FreePascal/Lazarus(!), Node-Webkit and Atom-Shell.
    I'm going to see which one's the easiest to work with and produces
    the best stuff with WordBird. Once that's done, I can get back to
    considering the GUI here.
